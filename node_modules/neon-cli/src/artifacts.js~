import BuildSettings from './build-settings';
import { writeFileSync } from 'fs';

// The artifacts file keeps track of the state of all build artifacts. This
// includes the results of cargo builds in the Rust `target` directory as well
// as the main .node addon file.
//
// The artifacts file has the following structure:
//
// {
//   "active": string[],
//   "target": virtualfs
// }
//
// The virtualfs is a JSON object tree that parallels the structure of the Rust
// `target` directory.
//
// On Windows, this can look like:
//
//   i686-pc-windows-msvc/
//     debug/
//     release/
//   x86_64-pc-windows-msvc/
//     debug/
//     release/
//
// On Linux and macOS, this can look like:
//
//   debug/
//   release/
//
// The build state file stores this structure as a JSON tree, e.g. in Windows:
//
//   {
//     "active": ["x86_64-pc-windows-msvc", "release"],
//     "entries": {
//       "i686-pc-windows-msvc": {
//         "debug": ...,
//         "release": ...
//       },
//       "x86_64-pc-windows-msvc": {
//         "debug": ...,
//         "release": ...
//       }
//     }
//   }
//
// The "active" key indicates which entry is the currently active build, i.e.,
// which build was copied into the main .node addon file.
//
// The "entries" key is the tree of build entries in the `target` directory.

function parse(json, entries = {}) {
  if (json.debug || json.release) {
    if (json.debug) {
      entries.debug = BuildSettings.fromJSON(json.debug);
    }
    if (json.release) {
      entries.release = BuildSettings.fromJSON(json.release);
    }
  } else {
    for (let key of Object.keys(json)) {
      entries[key] = parse(json[key]);
    }
  }

  return entries;
}

function deleteEntry(entries, path, i) {
  if (i === path.length - 1) {
    delete entries[path[i]];
  } else {
    deleteEntry(entries[path[i]], path, i + 1);
    if (Object.keys(subtree).length === 0) {
      delete entries[path[i]];
    }
  }
}

function jsonify(entries) {
  let result = {};

  if (entries.debug || entries.release) {
    if (entries.debug) {
      result.debug = entries.debug.toJSON();
    }
    if (entries.release) {
      result.release = entries.release.toJSON();
    }
  } else {
    for (let key of Object.keys(entries)) {
      result[key] = jsonify(entries[key]);
    }
  }

  return result;
}

export default class BuildState {

  constructor(entries = {}, active = null) {
    this.active = active;
    this._entries = entries;
  }

  static load(file) {
    try {
      let json = require(file);
      return new BuildState(parse(json.entries), json.active);
    } catch (e) {
      return new BuildState();
    }
  }

  toJSON() {
    return {
      active: this.active,
      entries: jsonify(this._entries)
    };
  }

  save(file) {
    fs.writeFileSync(file, JSON.stringify(this.toJSON()));
  }

  get(path) {
    let entries = this._entries;

    for (let i = 0, n = path.length; i < n; i++) {
      entries = entries[path[i]];
      if (!entries) {
        return null;
      }
    }

    return entries;
  }

  setActive(path, settings) {
    let entries = this._entries;

    for (let i = 0, n = path.length - 1; i < n; i++) {
      entries = entries[path[i]];
      if (!entries) {
        entries = entries[path[i]] = {};
      }
    }

    entries[path[path.length - 1]] = settings;

    this.active = path;
  }

  delete(path) {
    deleteEntry(this._entries, path, 0);

    // If the path being deleted was the active one, there's no more active path.
    if (this.active && path.length === this.active.length && path.every((x, i) => x === this.active[i])) {
      this.active = null;
    }
  }

}
