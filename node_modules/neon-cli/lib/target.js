'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('./async/fs');

var _rust = require('./rust');

var rust = _interopRequireWildcard(_rust);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const LIB_PREFIX = {
  'darwin': "lib",
  'freebsd': "lib",
  'linux': "lib",
  'sunos': "lib",
  'win32': ""
};

const LIB_SUFFIX = {
  'darwin': ".dylib",
  'freebsd': ".so",
  'linux': ".so",
  'sunos': ".so",
  'win32': ".dll"
};

// Represents the Rust build artifacts for a single build target of a Neon crate.
class Target {

  constructor(crate) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$release = options.release;
    let release = _options$release === undefined ? true : _options$release;
    var _options$arch = options.arch;
    let arch = _options$arch === undefined ? process.env.npm_config_arch || process.arch : _options$arch;

    this.crate = crate;
    this.release = release;
    this.arch = arch;

    if (process.platform === 'win32') {
      this.triple = arch === 'ia32' ? 'i686-pc-windows-msvc' : 'x86_64-pc-windows-msvc';
    } else {
      this.triple = '';
    }

    this.subdirectory = _path2.default.join(this.triple, release ? 'release' : 'debug');
    this.root = _path2.default.resolve(crate.root, 'target', this.subdirectory);

    let prefix = LIB_PREFIX[process.platform];
    let suffix = LIB_SUFFIX[process.platform];
    this.dylib = _path2.default.resolve(this.root, prefix + crate.name + suffix);
  }

  clean() {
    var _this = this;

    return _asyncToGenerator(function* () {
      // Remove the directory associated with this target.
      yield (0, _fs.remove)(_path2.default.resolve(_this.crate.root, 'target', _this.subdirectory));

      // If this target was the active target, remove the addon.
      if (_this.crate.artifacts.active === _this.subdirectory) {
        yield _this.crate.removeAddon();
      }

      // Update the build state.
      _this.crate.artifacts.delete(_this.subdirectory);
      _this.crate.saveArtifacts();
    })();
  }

  build(toolchain, settings) {
    var _this2 = this;

    let abi = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.versions.modules;
    return _asyncToGenerator(function* () {
      let macos = process.platform === 'darwin';

      let command = macos ? 'rustc' : 'build';
      let releaseFlags = _this2.release ? ["--release"] : [];
      let extraFlags = macos ? ["--", "-C", "link-args=-Wl,-undefined,dynamic_lookup"] : [];
      let targetFlags = _this2.triple ? ["--target=" + _this2.triple] : [];

      let args = [command].concat(releaseFlags, extraFlags, targetFlags);

      try {
        let result = yield rust.spawn("cargo", args, toolchain, {
          cwd: _this2.crate.root,
          stdio: 'inherit',
          // Pass the Node modules ABI version to the build as an environment variable.
          env: Object.assign({}, process.env, { NEON_NODE_ABI: abi })
        });

        if (result !== 0) {
          throw new Error("cargo build failed");
        }

        _this2.crate.artifacts.activate(_this2.subdirectory, settings);

        return result;
      } catch (e) {
        _this2.crate.artifacts.delete(_this2.subdirectory);

        throw e;
      } finally {
        _this2.crate.saveArtifacts();
      }
    })();
  }

  inState(settings) {
    let savedSettings = this.crate.artifacts.lookup(this.subdirectory);
    return savedSettings && savedSettings.match(settings);
  }

}exports.default = Target;
;