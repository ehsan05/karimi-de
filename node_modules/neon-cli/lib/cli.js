'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _package = require('../package.json');

var _package2 = _interopRequireDefault(_package);

var _neon_new = require('./ops/neon_new');

var _neon_new2 = _interopRequireDefault(_neon_new);

var _neon_build = require('./ops/neon_build');

var _neon_build2 = _interopRequireDefault(_neon_build);

var _neon_clean = require('./ops/neon_clean');

var _neon_clean2 = _interopRequireDefault(_neon_clean);

var _style = require('./ops/style');

var style = _interopRequireWildcard(_style);

var _commandLineCommands = require('command-line-commands');

var _commandLineCommands2 = _interopRequireDefault(_commandLineCommands);

var _commandLineArgs = require('command-line-args');

var _commandLineArgs2 = _interopRequireDefault(_commandLineArgs);

var _commandLineUsage = require('command-line-usage');

var _commandLineUsage2 = _interopRequireDefault(_commandLineUsage);

var _log = require('./log');

var _log2 = _interopRequireDefault(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function channel(value) {
  if (!['default', 'nightly', 'beta', 'stable'].indexOf(value) > -1) {
    throw new Error("Expected one of 'default', 'nightly', 'beta', or 'stable', got '" + value + "'");
  }
  return value;
}

function profile(value) {
  if (!['debug', 'release', 'all'].indexOf(value) > -1) {
    throw new Error("Expected one of 'debug', 'release', or 'all', got '" + value + "'");
  }
  return value;
}

function commandUsage(command) {
  if (!spec[command]) {
    let e = new Error();
    e.command = command;
    e.name = 'INVALID_COMMAND';
    throw e;
  }
  console.error((0, _commandLineUsage2.default)(spec[command].usage));
}

function logIf(multiple, action, cwd, module) {
  if (multiple) {
    (0, _log2.default)(action + " Neon package at " + (_path2.default.relative(cwd, module) || "."));
  }
}

function parseModules(cwd, names, paths) {
  let modules = names ? names.map(m => paths ? _path2.default.resolve(cwd, m) : _path2.default.resolve(cwd, 'node_modules', m)) : [cwd];

  return {
    modules: modules,
    multiple: modules.length > 1
  };
}

const spec = {

  null: {
    args: [{ name: "version", alias: "v", type: Boolean }, { name: "help", alias: "h", type: String, defaultValue: null }],
    usage: [{
      header: "Neon",
      content: "Neon is a tool for building native Node.js modules with Rust."
    }, {
      header: "Synopsis",
      content: "$ neon [options] <command>"
    }, {
      header: "Command List",
      content: [{ name: "new", summary: "Create a new Neon project." }, { name: "build", summary: "(Re)build a Neon project." }, { name: "clean", summary: "Remove build artifacts from a Neon project." }, { name: "version", summary: "Display the Neon version." }, { name: "help", summary: "Display help information about Neon." }]
    }],
    action: function action(options, usage) {
      if (options.version && options.help === undefined) {
        spec.version.action.call(this, options);
      } else if (options.help !== undefined) {
        commandUsage(options.help);
      } else {
        console.error(usage);
      }
    }
  },

  help: {
    args: [{ name: "command", type: String, defaultOption: true }, { name: "help", alias: "h", type: Boolean }],
    usage: [{
      header: "neon help",
      content: "Get help about a Neon command"
    }, {
      header: "Synopsis",
      content: "$ neon help [command]"
    }],
    action: function action(options) {
      if (options && options.command) {
        commandUsage(options.command);
      } else if (options && options.help) {
        commandUsage('help');
      } else {
        console.error((0, _commandLineUsage2.default)(spec.null.usage));
      }
    }
  },

  new: {
    args: [{ name: "name", type: String, defaultOption: true }, { name: "help", alias: "h", type: Boolean }],
    usage: [{
      header: "neon new",
      content: "Create a new Neon project."
    }, {
      header: "Synopsis",
      content: "$ neon new [@<scope>/]<name>"
    }],
    action: function action(options) {
      if (options.help) {
        commandUsage('new');
        return;
      }

      return (0, _neon_new2.default)(this.cwd, options.name);
    }
  },

  build: {
    args: [{ name: "debug", alias: "d", type: Boolean }, { name: "path", alias: "p", type: Boolean }, { name: "rust", alias: "r", type: channel, defaultValue: "default" }, { name: "modules", type: String, multiple: true, defaultOption: true }, { name: "node_module_version", type: Number }, { name: "help", alias: "h", type: Boolean }],
    usage: [{
      header: "neon build",
      content: "(Re)build a Neon project."
    }, {
      header: "Synopsis",
      content: ["$ neon build [options]", "$ neon build [options] [underline]{module} ..."]
    }, {
      header: "Options",
      optionList: [{
        name: "rust",
        alias: "r",
        type: channel,
        description: "Rust channel (default, nightly, beta, or stable). [default: default]"
      }, {
        name: "debug",
        alias: "d",
        type: Boolean,
        description: "Debug build."
      }, {
        name: "path",
        alias: "p",
        type: Boolean,
        description: "Specify modules by path instead of name."
      }]
    }],
    action: (() => {
      var _ref = _asyncToGenerator(function* (options) {
        if (options.help) {
          commandUsage('build');
          return;
        }

        var _parseModules = parseModules(this.cwd, options.modules, options.path);

        let modules = _parseModules.modules,
            multiple = _parseModules.multiple;


        for (let module of modules) {
          logIf(multiple, "building", this.cwd, module);

          yield (0, _neon_build2.default)(module, options.rust, !options.debug, options.node_module_version);
        }
      });

      function action(_x) {
        return _ref.apply(this, arguments);
      }

      return action;
    })()
  },

  clean: {
    args: [{ name: "path", alias: "p", type: Boolean }, { name: "modules", type: String, multiple: true, defaultOption: true }, { name: "help", alias: "h", type: Boolean }],
    usage: [{
      header: "neon clean",
      content: "Remove build artifacts from a Neon project."
    }, {
      header: "Synopsis",
      content: ["$ neon clean [options]", "$ neon clean [options] [underline]{module} ..."]
    }, {
      header: "Options",
      optionList: [{
        name: "path",
        alias: "p",
        type: Boolean,
        description: "Specify modules by path instead of name."
      }]
    }],
    action: (() => {
      var _ref2 = _asyncToGenerator(function* (options) {
        if (options.help) {
          commandUsage('clean');
          return;
        }

        var _parseModules2 = parseModules(this.cwd, options.modules, options.path);

        let modules = _parseModules2.modules,
            multiple = _parseModules2.multiple;


        for (let module of modules) {
          logIf(multiple, "cleaning", this.cwd, module);

          yield (0, _neon_clean2.default)(module);
        }
      });

      function action(_x2) {
        return _ref2.apply(this, arguments);
      }

      return action;
    })()
  },

  version: {
    args: [{ name: "help", alias: "h", type: Boolean }],
    usage: [{
      header: "neon version",
      content: "Display the Neon version."
    }, {
      header: "Synopsis",
      content: "$ neon version"
    }],
    action: function action(options) {
      if (options.help) {
        commandUsage('version');
        return;
      }

      console.log(_package2.default.version);
    }
  }

};

class CLI {
  constructor(argv, cwd) {
    this.argv = argv.slice(2);
    this.cwd = cwd;
  }

  exec() {
    var _this = this;

    return _asyncToGenerator(function* () {
      (0, _log.setup)(function (msg) {
        console.log(style.info(msg));
      });

      try {
        var _parseCommands = (0, _commandLineCommands2.default)([null, 'help', 'new', 'build', 'clean', 'version'], _this.argv);

        let command = _parseCommands.command,
            argv = _parseCommands.argv;


        yield spec[command].action.call(_this, (0, _commandLineArgs2.default)(spec[command].args, { argv: argv }), (0, _commandLineUsage2.default)(spec[command].usage));
      } catch (e) {
        spec.help.action.call(_this);

        switch (e.name) {
          case 'INVALID_COMMAND':
            console.error(style.error("No manual entry for `neon " + e.command + "`"));
            break;

          default:
            console.error(style.error(e.message));
            break;
        }
      }
    })();
  }
}
exports.default = CLI;